<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Hand Control - Precise Picking</title>
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-purple: #ff00ea;
            --neon-yellow: #ffea00;
            --neon-green: #39ff14;
            --neon-red: #ff3131;
            --dark-bg: #050505;
            --panel-bg: rgba(0, 242, 255, 0.08);
        }

        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--dark-bg);
            font-family: 'Courier New', Courier, monospace;
            color: var(--neon-blue);
        }

        #input_video { display: none; }

        #output_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 5;
            transform: scaleX(-1);
            will-change: transform;
        }

        .ui-overlay {
            position: absolute;
            top: 20px; left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        .status-panel {
            background: var(--panel-bg);
            border: 1px solid var(--neon-blue);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .mode-indicator {
            font-size: 1.4rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-top: 8px;
            display: block;
            text-shadow: 0 0 8px var(--neon-blue);
        }

        .clear-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 20;
            background: rgba(255, 49, 49, 0.1);
            border: 1px solid var(--neon-red);
            color: var(--neon-red);
            padding: 12px 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 4px;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(255, 49, 49, 0.2);
            pointer-events: auto;
        }

        .clear-btn:hover {
            background: var(--neon-red);
            color: #fff;
            box-shadow: 0 0 20px var(--neon-red);
        }

        .instructions {
            position: absolute;
            bottom: 20px; right: 20px;
            font-size: 0.85rem;
            text-align: right;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-right: 4px solid var(--neon-blue);
            z-index: 10;
            line-height: 1.6;
        }

        #loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: var(--dark-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .loader {
            border: 3px solid #111;
            border-top: 3px solid var(--neon-blue);
            border-radius: 50%;
            width: 40px; height: 40px;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <p style="margin-top: 20px; letter-spacing: 3px;">Y√úKL∆èNƒ∞R...</p>
    </div>

    <button class="clear-btn" onclick="clearCanvas()">üóë T∆èMƒ∞ZL∆è</button>

    <div class="ui-overlay">
        <div class="status-panel">
            <div style="font-size: 0.7rem; opacity: 0.7;">Sƒ∞STEM: OPTƒ∞Mƒ∞Z∆è EDƒ∞LDƒ∞</div>
            <div class="mode-indicator" id="current-mode">M√ú≈ûAHƒ∞D∆è</div>
        </div>
    </div>

    <div class="instructions">
        [TUTMA M∆èNTƒ∞Qƒ∞]<br>
        1. Obyektin x…ôttin…ô yaxƒ±nla≈üƒ±n<br>
        2. Ba≈ü v…ô ≈ü…ôhad…ôt barmaƒüƒ± sƒ±xƒ±n (Pinch)<br>
        3. <span style="color:var(--neon-green)">X∆èTD∆èN TUTUB</span> h…ôr…ôk…ôt etdirin
    </div>

    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d', { alpha: false });
        const modeText = document.getElementById('current-mode');
        const loadingScreen = document.getElementById('loading-screen');

        let drawings = []; 
        let currentPath = null;
        let selectedDrawing = null;
        let isDragging = false;
        let currentMode = "M√ú≈ûAHƒ∞D∆è";

        let lastFingerPos = { x: 0, y: 0 };
        let initialDistance = null;
        let initialScale = 1;
        let initialAngle = null;
        let drawingBaseAngle = 0;

        function setupCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', setupCanvas);
        setupCanvas();

        function clearCanvas() {
            drawings = [];
            selectedDrawing = null;
            currentPath = null;
        }

        function getDist(p1, p2) {
            return Math.sqrt(Math.pow((p1.x - p2.x) * canvasElement.width, 2) + Math.pow((p1.y - p2.y) * canvasElement.height, 2));
        }

        function isFist(landmarks) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            const wrist = landmarks[0];
            return tips.every((tIdx, i) => {
                const tipDist = getDist(landmarks[tIdx], wrist);
                const pipDist = getDist(landmarks[pips[i]], wrist);
                return tipDist < pipDist;
            });
        }

        function isPalmOpen(landmarks) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            return tips.every((tIdx, i) => landmarks[tIdx].y < landmarks[pips[i]].y);
        }

        // X∆èTTƒ∞N √úZ∆èRƒ∞ND∆è OLUB OLMADIƒûINI YOXLAMAQ (Hit Detection)
        function findDrawingAt(x, y) {
            const hitPadding = 30; // X…ôtt…ô toxunma h…ôssaslƒ±ƒüƒ± (px)
            
            for (let i = drawings.length - 1; i >= 0; i--) {
                const d = drawings[i];
                // H…ôr bir x…ôtt seqmentini yoxlayƒ±rƒ±q
                for (let j = 0; j < d.points.length; j++) {
                    const p = d.points[j];
                    // Obyektin m√∂vcud scale v…ô rotation v…ôziyy…ôtini n…ôz…ôr…ô alaraq sad…ô m…ôsaf…ô yoxlamasƒ±
                    const dx = x - p.x;
                    const dy = y - p.y;
                    if (Math.sqrt(dx*dx + dy*dy) < hitPadding * (d.scale || 1)) {
                        return d;
                    }
                }
            }
            return null;
        }

        function onResults(results) {
            if (loadingScreen.style.display !== 'none') loadingScreen.style.display = 'none';

            requestAnimationFrame(() => {
                canvasCtx.fillStyle = '#050505';
                canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

                drawAll();

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const hands = results.multiHandLandmarks;

                    if (hands.length === 2 && isPalmOpen(hands[0]) && isPalmOpen(hands[1])) {
                        processScale(hands[0], hands[1]);
                    } else {
                        processSingleHand(hands[0]);
                        initialDistance = null;
                    }

                    hands.forEach(drawHandUI);
                } else {
                    setMode("M√ú≈ûAHƒ∞D∆è");
                    currentPath = null;
                    isDragging = false;
                    selectedDrawing = null;
                    initialAngle = null;
                }
            });
        }

        function processSingleHand(hand) {
            const thumbTip = hand[4];
            const indexTip = hand[8];
            const middleTip = hand[12];
            const wrist = hand[0];

            // Orta n√∂qt…ô (Barmaqlarƒ±n sƒ±xƒ±ldƒ±ƒüƒ± yer)
            const pinchX = ((thumbTip.x + indexTip.x) / 2) * canvasElement.width;
            const pinchY = ((thumbTip.y + indexTip.y) / 2) * canvasElement.height;

            const pinchDist = getDist(thumbTip, indexTip);
            const isPinching = pinchDist < 40;

            if (isFist(hand)) {
                setMode("D√ñND√úRM∆è");
                if (!selectedDrawing) selectedDrawing = findDrawingAt(pinchX, pinchY);
                if (selectedDrawing) {
                    const angle = Math.atan2(indexTip.y - wrist.y, indexTip.x - wrist.x);
                    if (initialAngle === null) {
                        initialAngle = angle;
                        drawingBaseAngle = selectedDrawing.rotation || 0;
                    } else {
                        selectedDrawing.rotation = drawingBaseAngle + (angle - initialAngle);
                    }
                }
            } else if (isPinching) {
                setMode("DA≈ûIMA");
                if (!isDragging) {
                    selectedDrawing = findDrawingAt(pinchX, pinchY);
                    if (selectedDrawing) {
                        isDragging = true;
                        lastFingerPos = { x: pinchX, y: pinchY };
                    }
                }
                
                if (isDragging && selectedDrawing) {
                    const dx = pinchX - lastFingerPos.x;
                    const dy = pinchY - lastFingerPos.y;
                    
                    selectedDrawing.points.forEach(p => {
                        p.x += dx;
                        p.y += dy;
                    });
                    lastFingerPos = { x: pinchX, y: pinchY };
                }
                currentPath = null;
            } else if (indexTip.y < hand[6].y && middleTip.y > hand[10].y) {
                setMode("CIZMA");
                selectedDrawing = null;
                isDragging = false;
                initialAngle = null;

                if (!currentPath) {
                    currentPath = { points: [], scale: 1, rotation: 0, color: '#00f2ff' };
                    drawings.push(currentPath);
                }
                currentPath.points.push({ x: indexTip.x * canvasElement.width, y: indexTip.y * canvasElement.height });
            } else {
                setMode("M√ú≈ûAHƒ∞D∆è");
                currentPath = null;
                selectedDrawing = null;
                isDragging = false;
                initialAngle = null;
            }
        }

        function processScale(h1, h2) {
            setMode("B√ñY√úTM∆è");
            const d = getDist(h1[8], h2[8]);
            const midX = (h1[8].x + h2[8].x) / 2 * canvasElement.width;
            const midY = (h1[8].y + h2[8].y) / 2 * canvasElement.height;

            if (!selectedDrawing) selectedDrawing = findDrawingAt(midX, midY);

            if (selectedDrawing) {
                if (initialDistance === null) {
                    initialDistance = d;
                    initialScale = selectedDrawing.scale || 1;
                } else {
                    selectedDrawing.scale = initialScale * (d / initialDistance);
                }
            }
        }

        function setMode(m) {
            if (currentMode !== m) {
                currentMode = m;
                modeText.innerText = m;
                const colors = {
                    "CIZMA": "var(--neon-blue)",
                    "DA≈ûIMA": "var(--neon-green)",
                    "D√ñND√úRM∆è": "var(--neon-yellow)",
                    "B√ñY√úTM∆è": "var(--neon-purple)",
                    "M√ú≈ûAHƒ∞D∆è": "var(--neon-blue)"
                };
                modeText.style.color = colors[m] || "white";
            }
        }

        function drawAll() {
            for (let i = 0; i < drawings.length; i++) {
                const d = drawings[i];
                if (d.points.length < 2) continue;
                
                canvasCtx.save();
                // Obyektin lokal m…ôrk…ôzi (da≈üƒ±ma √º√ß√ºn m…ôrk…ôz n√∂qt…ôsi lazƒ±m deyil √ß√ºnki koordinatlarƒ± d…ôyi≈üirik)
                // Lakin Scale v…ô Rotation ilk n√∂qt…ô …ôtrafƒ±nda ba≈ü verir
                const cx = d.points[0].x;
                const cy = d.points[0].y;
                
                canvasCtx.translate(cx, cy);
                canvasCtx.scale(d.scale || 1, d.scale || 1);
                canvasCtx.rotate(d.rotation || 0);
                canvasCtx.translate(-cx, -cy);

                canvasCtx.beginPath();
                // Se√ßilmi≈ü obyekti f…ôrql…ôndiririk
                if (selectedDrawing === d) {
                    canvasCtx.strokeStyle = "#ffffff";
                    canvasCtx.shadowBlur = 20;
                    canvasCtx.shadowColor = d.color;
                    canvasCtx.lineWidth = 6;
                } else {
                    canvasCtx.strokeStyle = d.color;
                    canvasCtx.lineWidth = 4;
                    canvasCtx.shadowBlur = 5;
                    canvasCtx.shadowColor = d.color;
                }

                canvasCtx.lineCap = 'round';
                canvasCtx.lineJoin = 'round';

                canvasCtx.moveTo(d.points[0].x, d.points[0].y);
                for (let j = 1; j < d.points.length; j++) {
                    canvasCtx.lineTo(d.points[j].x, d.points[j].y);
                }
                canvasCtx.stroke();
                canvasCtx.restore();
            }
        }

        function drawHandUI(landmarks) {
            canvasCtx.strokeStyle = 'rgba(0, 242, 255, 0.4)';
            canvasCtx.lineWidth = 2;
            
            HAND_CONNECTIONS.forEach(([start, end]) => {
                const p1 = landmarks[start];
                const p2 = landmarks[end];
                canvasCtx.beginPath();
                canvasCtx.moveTo(p1.x * canvasElement.width, p1.y * canvasElement.height);
                canvasCtx.lineTo(p2.x * canvasElement.width, p2.y * canvasElement.height);
                canvasCtx.stroke();
            });

            // Vizual indikator (Pinch n√∂qt…ôsi)
            const tipIdx = (currentMode === "DA≈ûIMA") ? 4 : 8;
            const tip = landmarks[tipIdx];
            canvasCtx.beginPath();
            canvasCtx.arc(tip.x * canvasElement.width, tip.y * canvasElement.height, 8, 0, Math.PI*2);
            canvasCtx.fillStyle = (currentMode === "DA≈ûIMA") ? "var(--neon-green)" : "var(--neon-blue)";
            canvasCtx.fill();
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0, 
            minDetectionConfidence: 0.65,
            minTrackingConfidence: 0.65
        });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => await hands.send({ image: videoElement }),
            width: 640, 
            height: 480
        });
        camera.start();
    </script>
</body>
</html>
