<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mavi Saturn - İnteraktiv Toz Zərrəcikləri</title>
    <!-- MediaPipe Kitabxanaları -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #input-video { display: none; }
        #loading-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-size: 1.2rem; text-align: center; pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="loading-msg">Sistem yüklənir...<br><small>Kameraya icazə verin</small></div>
    <video id="input-video" playsinline></video>

    <script>
        let scene, camera, renderer, saturn, rings, stars;
        let handGroup, handSkeleton, handPoints;
        let lastHandPos = null;
        let currentHandCenter = new THREE.Vector3(0, 0, 0); 
        let isExploded = false;
        let explosionFactor = 0;
        let shakeIntensity = 0;
        
        let saturnOrigPos = [];
        let ringOrigPos = [];
        let saturnRandomDirs = [];
        let ringRandomDirs = [];

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12; 
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Saturn (Mavi Rəngdə)
            const saturnGeo = new THREE.SphereGeometry(4, 64, 64);
            const saturnMat = new THREE.PointsMaterial({ color: 0x0088ff, size: 0.04 }); // Parlaq mavi
            saturn = new THREE.Points(saturnGeo, saturnMat);
            scene.add(saturn);

            const sPos = saturn.geometry.attributes.position.array;
            for(let i=0; i<sPos.length; i+=3) {
                saturnOrigPos.push(sPos[i], sPos[i+1], sPos[i+2]);
                saturnRandomDirs.push((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3);
            }

            // Halqalar (Mavi çalarlarda)
            const ringCount = 12000;
            const ringGeo = new THREE.BufferGeometry();
            const rPositions = new Float32Array(ringCount * 3);
            for(let i=0; i<ringCount; i++) {
                const r = 6.5 + Math.random() * 3.5;
                const a = Math.random() * Math.PI * 2;
                const x = Math.cos(a) * r;
                const y = (Math.random()-0.5) * 0.1;
                const z = Math.sin(a) * r;
                rPositions[i*3] = x;
                rPositions[i*3+1] = y;
                rPositions[i*3+2] = z;
                ringOrigPos.push(x, y, z);
                ringRandomDirs.push((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2);
            }
            ringGeo.setAttribute('position', new THREE.BufferAttribute(rPositions, 3));
            rings = new THREE.Points(ringGeo, new THREE.PointsMaterial({ color: 0x00ffff, size: 0.025, transparent: true, opacity: 0.6 }));
            rings.rotation.x = Math.PI / 3;
            scene.add(rings);

            // Ulduzlar
            const starGeo = new THREE.BufferGeometry();
            const starPos = new Float32Array(4000 * 3);
            for(let i=0; i<4000*3; i++) starPos[i] = (Math.random()-0.5) * 1000;
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.4})));

            // Skelet
            handGroup = new THREE.Group();
            const skeletonGeo = new THREE.BufferGeometry();
            const skeletonMat = new THREE.LineBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.8 });
            handSkeleton = new THREE.LineSegments(skeletonGeo, skeletonMat);
            const pointsGeo = new THREE.BufferGeometry();
            const pointsMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.08 });
            handPoints = new THREE.Points(pointsGeo, pointsMat);
            handGroup.add(handSkeleton);
            handGroup.add(handPoints);
            handGroup.position.set(0, 0, -10); 
            camera.add(handGroup);

            scene.add(new THREE.AmbientLight(0xffffff, 1));
            animate();
        }

        function isHandFist(landmarks) {
            const tips = [8, 12, 16, 20];
            const joints = [6, 10, 14, 18];
            let closedCount = 0;
            for(let i=0; i<4; i++) {
                if(landmarks[tips[i]].y > landmarks[joints[i]].y) closedCount++;
            }
            return closedCount >= 3;
        }

        function updateExplosion() {
            if(!saturn || !rings) return;
            const saturnAttr = saturn.geometry.attributes.position;
            const ringAttr = rings.geometry.attributes.position;
            
            const targetFactor = isExploded ? 8.0 : 0;
            explosionFactor = THREE.MathUtils.lerp(explosionFactor, targetFactor, isExploded ? 0.04 : 0.18);

            let attractionVector = new THREE.Vector3();
            if (isExploded) {
                attractionVector.copy(currentHandCenter);
                handGroup.localToWorld(attractionVector);
            }

            // Saturn hissəcikləri
            for(let i=0; i<saturnAttr.count; i++) {
                const i3 = i * 3;
                let x = saturnOrigPos[i3] + saturnRandomDirs[i3] * explosionFactor;
                let y = saturnOrigPos[i3+1] + saturnRandomDirs[i3+1] * explosionFactor;
                let z = saturnOrigPos[i3+2] + saturnRandomDirs[i3+2] * explosionFactor;

                if (isExploded) {
                    // Cəlb olunma sürəti artırıldı (0.05 -> 0.08)
                    x = THREE.MathUtils.lerp(x, attractionVector.x, 0.08);
                    y = THREE.MathUtils.lerp(y, attractionVector.y, 0.08);
                    z = THREE.MathUtils.lerp(z, attractionVector.z, 0.08);
                }

                saturnAttr.array[i3] = x;
                saturnAttr.array[i3+1] = y;
                saturnAttr.array[i3+2] = z;
            }
            saturnAttr.needsUpdate = true;

            // Halqa hissəcikləri
            for(let i=0; i<ringAttr.count; i++) {
                const i3 = i * 3;
                let x = ringOrigPos[i3] + ringRandomDirs[i3] * explosionFactor;
                let y = ringOrigPos[i3+1] + ringRandomDirs[i3+1] * explosionFactor;
                let z = ringOrigPos[i3+2] + ringRandomDirs[i3+2] * explosionFactor;

                if (isExploded) {
                    // Cəlb olunma sürəti artırıldı (0.03 -> 0.06)
                    x = THREE.MathUtils.lerp(x, attractionVector.x, 0.06);
                    y = THREE.MathUtils.lerp(y, attractionVector.y, 0.06);
                    z = THREE.MathUtils.lerp(z, attractionVector.z, 0.06);
                }

                ringAttr.array[i3] = x;
                ringAttr.array[i3+1] = y;
                ringAttr.array[i3+2] = z;
            }
            ringAttr.needsUpdate = true;

            if (shakeIntensity > 0.02) {
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                shakeIntensity *= 0.9;
            } else {
                camera.position.x = THREE.MathUtils.lerp(camera.position.x, 0, 0.1);
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, 0, 0.1);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateExplosion();
            if (!isExploded && !lastHandPos && saturn && rings) {
                saturn.rotation.y += 0.002;
                rings.rotation.z += 0.001;
            }
            renderer.render(scene, camera);
        }

        async function startApp() {
            initThree();

            const videoElement = document.getElementById('input-video');
            const loadingMsg = document.getElementById('loading-msg');
            
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            const handConnections = [
                [0,1],[1,2],[2,3],[3,4], [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12], [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20], [5,9],[9,13],[13,17]
            ];

            hands.onResults((results) => {
                if (loadingMsg) loadingMsg.style.display = 'none';
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const positions = [];
                    const linePositions = [];
                    
                    // Ovuc mərkəzini dinamik olaraq yeniləyirik
                    currentHandCenter.set(
                        ((1 - landmarks[9].x) - 0.5) * 15,
                        -(landmarks[9].y - 0.5) * 10,
                        0
                    );

                    landmarks.forEach(lm => {
                        const x = ((1 - lm.x) - 0.5) * 15; 
                        const y = -(lm.y - 0.5) * 10;
                        const z = 0; 
                        positions.push(x, y, z);
                    });

                    handConnections.forEach(([start, end]) => {
                        linePositions.push(positions[start*3], positions[start*3+1], positions[start*3+2]);
                        linePositions.push(positions[end*3], positions[end*3+1], positions[end*3+2]);
                    });

                    if(handPoints) handPoints.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    if(handSkeleton) handSkeleton.geometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
                    
                    const isFist = isHandFist(landmarks);
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];

                    const zoomDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                    const targetZ = 35 - (zoomDist * 110); 
                    camera.position.z = THREE.MathUtils.lerp(camera.position.z, Math.max(5, Math.min(targetZ, 60)), 0.1);

                    if (isFist) {
                        isExploded = false;
                        if (lastHandPos) {
                            const dx = (1 - indexTip.x) - (1 - lastHandPos.x);
                            const dy = indexTip.y - lastHandPos.y;
                            saturn.rotation.y += dx * 7;
                            saturn.rotation.x += dy * 7;
                            rings.rotation.y += dx * 7;
                            rings.rotation.x += dy * 7;
                        }
                        lastHandPos = indexTip;
                    } else {
                        // ƏL AÇIQDIR - Hissəciklər əli izləyir
                        isExploded = true;
                        lastHandPos = null;
                    }
                    if(handGroup) handGroup.visible = true;
                } else {
                    if(handGroup) handGroup.visible = false;
                    lastHandPos = null;
                    isExploded = false;
                }
            });

            if (typeof Camera !== 'undefined') {
                const cameraProvider = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 640, height: 480
                });
                cameraProvider.start();
            } else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                    videoElement.srcObject = stream;
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        const processFrame = async () => {
                            await hands.send({image: videoElement});
                            requestAnimationFrame(processFrame);
                        };
                        processFrame();
                    };
                } catch (err) {
                    if(loadingMsg) loadingMsg.innerText = "Xəta: Kameraya giriş mümkün deyil.";
                }
            }
        }

        window.onload = startApp;

        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
