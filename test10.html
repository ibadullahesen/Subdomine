<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pəncərələrarası Maqnit Kürələr</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', sans-serif; 
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(0, 242, 255, 0.7);
            font-size: 14px;
            letter-spacing: 1px;
            pointer-events: none;
            border-left: 2px solid #00f2ff;
            padding-left: 10px;
        }
    </style>
</head>
<body>

<div id="ui">Status: Digər kürələr axtarılır...<br>Effekt: Dinamik Maqnit Cəlbetmə (0-70%)</div>

<script>
    let scene, camera, renderer, points;
    const particleCount = 28000;
    const radius = 2.8;
    const initialPos = new Float32Array(particleCount * 3);
    
    const bc = new BroadcastChannel('sphere_sync');
    let otherWindows = {};
    const myId = Math.random().toString(36).substr(2, 9);

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const geo = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;

            initialPos[i * 3]     = radius * Math.cos(theta) * Math.sin(phi);
            initialPos[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
            initialPos[i * 3 + 2] = radius * Math.cos(phi);

            posArray[i * 3] = initialPos[i * 3];
            posArray[i * 3 + 1] = initialPos[i * 3 + 1];
            posArray[i * 3 + 2] = initialPos[i * 3 + 2];
        }

        geo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const mat = new THREE.PointsMaterial({
            color: 0x00f2ff,
            size: 0.02,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        points = new THREE.Points(geo, mat);
        scene.add(points);
    }

    function broadcastPosition() {
        bc.postMessage({
            id: myId,
            screenX: window.screenX,
            screenY: window.screenY,
            width: window.innerWidth,
            height: window.innerHeight,
            timestamp: Date.now()
        });
    }

    bc.onmessage = (ev) => {
        otherWindows[ev.data.id] = ev.data;
    };

    function animate() {
        requestAnimationFrame(animate);
        broadcastPosition();

        // Köhnəlmiş pəncərə məlumatlarını təmizlə
        const now = Date.now();
        for(let id in otherWindows) {
            if (now - otherWindows[id].timestamp > 1000) delete otherWindows[id];
        }

        const pos = points.geometry.attributes.position.array;
        
        let closestWin = null;
        let minDist = Infinity;

        // Ən yaxın pəncərəni və məsafəni tap
        for (let id in otherWindows) {
            if (id === myId) continue;
            const other = otherWindows[id];
            
            const myCenterX = window.screenX + window.innerWidth / 2;
            const myCenterY = window.screenY + window.innerHeight / 2;
            const otherCenterX = other.screenX + other.width / 2;
            const otherCenterY = other.screenY + other.height / 2;

            const dx = otherCenterX - myCenterX;
            const dy = myCenterY - otherCenterY; // Y oxu ekranda aşağı doğrudur
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < minDist) {
                minDist = dist;
                closestWin = { dx, dy, dist };
            }
        }

        let pullStrength = 0;
        let targetX_Offset = 0;
        let targetY_Offset = 0;

        if (closestWin) {
            const threshold = 1200; // Cəlbetmənin başladığı məsafə
            if (closestWin.dist < threshold) {
                // 0-dan 1-ə doğru güclənən faktor
                pullStrength = 1 - (closestWin.dist / threshold);
                
                // Hissəciklərin hara doğru dartılacağı (digər pəncərənin mərkəzi)
                // Three.js koordinat sisteminə uyğunlaşdırma (təxmini faktor: 0.015)
                targetX_Offset = closestWin.dx * 0.015 * pullStrength;
                targetY_Offset = closestWin.dy * 0.015 * pullStrength;
            }
        }

        for (let i = 0; i < particleCount; i++) {
            const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

            // Hər hissəcik üçün fərdi gecikmə/variasiya əlavə edirik ki, "axın" effekti yaransın
            const variation = (Math.sin(i * 0.1) + 1) * 0.5;
            const individualPull = pullStrength * (0.8 + variation * 0.4);

            const targetX = initialPos[ix] + (targetX_Offset * (0.5 + variation));
            const targetY = initialPos[iy] + (targetY_Offset * (0.5 + variation));
            const targetZ = initialPos[iz];

            // Yumşaq keçid (Lerp)
            pos[ix] += (targetX - pos[ix]) * 0.1;
            pos[iy] += (targetY - pos[iy]) * 0.1;
            pos[iz] += (targetZ - pos[iz]) * 0.1;
        }

        points.geometry.attributes.position.needsUpdate = true;
        
        // Fırlanma hərəkəti (yaxınlaşdıqca yavaşlayır ki, birləşmə anı sabit görünsün)
        points.rotation.y += 0.003 * (1 - pullStrength * 0.8);

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.onload = () => {
        init();
        animate();
    };
</script>
</body>
</html>
