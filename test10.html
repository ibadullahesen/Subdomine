<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pəncərələrarası Maqnit Kürələr</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Segoe UI', sans-serif; 
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(0, 242, 255, 0.7);
            font-size: 14px;
            letter-spacing: 1px;
            pointer-events: none;
            border-left: 2px solid #00f2ff;
            padding-left: 10px;
        }
    </style>
</head>
<body>

<div id="ui">Status: Pəncərələr izlənilir...<br>Effekt: Maqnit Cəlbetmə</div>

<script>
    let scene, camera, renderer, points;
    const particleCount = 28000;
    const radius = 2.8;
    const initialPos = new Float32Array(particleCount * 3);
    
    // Pəncərələr arası əlaqə üçün kanal
    const bc = new BroadcastChannel('sphere_sync');
    let otherWindows = {};
    const myId = Math.random().toString(36).substr(2, 9);

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const geo = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;

            initialPos[i * 3]     = radius * Math.cos(theta) * Math.sin(phi);
            initialPos[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
            initialPos[i * 3 + 2] = radius * Math.cos(phi);

            posArray[i * 3] = initialPos[i * 3];
            posArray[i * 3 + 1] = initialPos[i * 3 + 1];
            posArray[i * 3 + 2] = initialPos[i * 3 + 2];
        }

        geo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const mat = new THREE.PointsMaterial({
            color: 0x00f2ff,
            size: 0.02,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        points = new THREE.Points(geo, mat);
        scene.add(points);
    }

    // Pəncərənin ekran koordinatlarını göndərir
    function broadcastPosition() {
        bc.postMessage({
            id: myId,
            screenX: window.screenX,
            screenY: window.screenY,
            width: window.innerWidth,
            height: window.innerHeight
        });
    }

    bc.onmessage = (ev) => {
        otherWindows[ev.data.id] = ev.data;
    };

    function animate() {
        requestAnimationFrame(animate);
        broadcastPosition();

        const pos = points.geometry.attributes.position.array;
        
        // Ən yaxın pəncərəni tap
        let closestWin = null;
        let minDist = Infinity;

        for (let id in otherWindows) {
            if (id === myId) continue;
            const other = otherWindows[id];
            
            // Pəncərələr arasındakı ekran məsafəsi
            const dx = (window.screenX + window.innerWidth/2) - (other.screenX + other.width/2);
            const dy = (window.screenY + window.innerHeight/2) - (other.screenY + other.height/2);
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < minDist) {
                minDist = dist;
                closestWin = { dx, dy, dist };
            }
        }

        // Maqnit effekti məntiqi
        let attractX = 0;
        let attractY = 0;
        let pullFactor = 0;

        if (closestWin) {
            // 70% yaxınlıq həddi (təxmini 1000px ekran məsafəsi kimi götürək)
            const threshold = 1000; 
            if (closestWin.dist < threshold) {
                // Məsafə azaldıqca güclənən faktor (0-dan 1-ə)
                pullFactor = Math.pow(1 - (closestWin.dist / threshold), 2);
                
                // Pəncərə kənarına getdikcə güclənən meyl
                attractX = -closestWin.dx * 0.01 * pullFactor;
                attractY = closestWin.dy * 0.01 * pullFactor; // Screen Y tərsdir
            }
        }

        for (let i = 0; i < particleCount; i++) {
            const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

            // Hissəcikləri digər pəncərəyə doğru çək
            const targetX = initialPos[ix] + attractX;
            const targetY = initialPos[iy] + attractY;
            const targetZ = initialPos[iz];

            pos[ix] += (targetX - pos[ix]) * 0.1;
            pos[iy] += (targetY - pos[iy]) * 0.1;
            pos[iz] += (targetZ - pos[iz]) * 0.1;
        }

        points.geometry.attributes.position.needsUpdate = true;
        points.rotation.y += 0.003;

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.onload = () => {
        init();
        animate();
    };
</script>
</body>
</html>
