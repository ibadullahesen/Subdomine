<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #webcam { 
            position: absolute;
            visibility: hidden;
            width: 1px;
            height: 1px;
        }
        #overlay-text {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(0, 251, 255, 0.5);
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="overlay-text">SİSTEM SİNXRONLAŞDIRILDI - UZANMA AKTİVDİR</div>
<video id="webcam" autoplay playsinline></video>

<script>
    let scene, camera, renderer, points;
    let handLines = [];
    const particleCount = 28000;
    
    const initialPos = new Float32Array(particleCount * 3); 
    const explosionVelocities = new Float32Array(particleCount * 3);
    
    let isDisintegrated = false;
    let isPinching = false;
    let handPos3D = new THREE.Vector3();
    let pinchPoint = new THREE.Vector3(); 

    const videoElement = document.getElementById('webcam');

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const geo = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            const r = 2.8;

            initialPos[i * 3] = r * Math.cos(theta) * Math.sin(phi);
            initialPos[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
            initialPos[i * 3 + 2] = r * Math.cos(phi);

            posArray[i * 3] = initialPos[i * 3];
            posArray[i * 3 + 1] = initialPos[i * 3 + 1];
            posArray[i * 3 + 2] = initialPos[i * 3 + 2];
        }

        geo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const mat = new THREE.PointsMaterial({
            color: 0x00f2ff,
            size: 0.02,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        points = new THREE.Points(geo, mat);
        scene.add(points);

        const lineMat = new THREE.LineBasicMaterial({ color: 0x00fbff, transparent: true, opacity: 0.6 });
        for(let i=0; i<42; i++) {
            const l = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), lineMat);
            scene.add(l);
            handLines.push(l);
        }
    }

    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.8,
        minTrackingConfidence: 0.8
    });

    hands.onResults(onResults);

    function onResults(results) {
        handLines.forEach(l => l.visible = false);

        if (results.multiHandLandmarks) {
            results.multiHandLandmarks.forEach((landmarks, index) => {
                const label = results.multiHandedness[index].label;
                drawSkeletalHand(landmarks, index * 21);
                
                const correctedX = (0.5 - landmarks[8].x) * 16;
                const correctedY = (0.5 - landmarks[8].y) * 12;

                if (label === 'Right') { // İstifadəçinin real Sol əli
                    const dThumbIndex = getDist(landmarks[4], landmarks[8]);
                    handPos3D.set(correctedX, correctedY, 0);

                    if (dThumbIndex < 0.05) {
                        if (!isPinching) {
                            // Dünyanın mövcud mövqeyini nəzərə alaraq lokal tutma nöqtəsini daxili koordinatlara çeviririk
                            pinchPoint.set(correctedX - points.position.x, correctedY - points.position.y, 0);
                        }
                        isPinching = true;
                    } else {
                        isPinching = false;
                    }

                    const isFist = (landmarks[8].y > landmarks[6].y && landmarks[12].y > landmarks[10].y && landmarks[16].y > landmarks[14].y);
                    if(isFist && !isDisintegrated) {
                        for (let i = 0; i < particleCount; i++) {
                            const speed = 0.6 + Math.random() * 0.8;
                            explosionVelocities[i * 3] = (Math.random() - 0.5) * speed;
                            explosionVelocities[i * 3 + 1] = (Math.random() - 0.5) * speed;
                            explosionVelocities[i * 3 + 2] = (Math.random() - 0.5) * speed;
                        }
                    }
                    isDisintegrated = isFist;
                } else if (label === 'Left') { // İstifadəçinin real Sağ əli
                    points.position.x += (correctedX - points.position.x) * 0.1;
                    points.position.y += (correctedY - points.position.y) * 0.1;
                }
            });
        }

        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            isPinching = false;
            isDisintegrated = false;
        }
    }

    function drawSkeletalHand(landmarks, offset) {
        const paths = [[0,1,2,3,4], [0,5,6,7,8], [5,9,13,17], [0,17,18,19,20], [9,10,11,12], [13,14,15,16]];
        let idx = offset;
        paths.forEach(p => {
            for(let i=0; i<p.length-1; i++) {
                const l = handLines[idx++];
                if(!l) return;
                const v1 = new THREE.Vector3((0.5 - landmarks[p[i]].x) * 16, (0.5 - landmarks[p[i]].y) * 12, -landmarks[p[i]].z * 15);
                const v2 = new THREE.Vector3((0.5 - landmarks[p[i+1]].x) * 16, (0.5 - landmarks[p[i+1]].y) * 12, -landmarks[p[i+1]].z * 15);
                l.geometry.setFromPoints([v1, v2]);
                l.visible = true;
            }
        });
    }

    function getDist(p1, p2) {
        return Math.sqrt(Math.pow(p1.x-p2.x, 2) + Math.pow(p1.y-p2.y, 2));
    }

    function animate() {
        requestAnimationFrame(animate);
        const pos = points.geometry.attributes.position.array;
        const worldX = points.position.x;
        const worldY = points.position.y;

        for (let i = 0; i < particleCount; i++) {
            const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

            if (isDisintegrated) {
                pos[ix] += explosionVelocities[ix];
                pos[iy] += explosionVelocities[iy];
                pos[iz] += explosionVelocities[iz];
                explosionVelocities[ix] *= 0.98;
                explosionVelocities[iy] *= 0.98;
                explosionVelocities[iz] *= 0.98;
            } else if (isPinching) {
                // Əlin dünyadan asılı olmayan lokal hərəkəti
                const localHandX = handPos3D.x - worldX;
                const localHandY = handPos3D.y - worldY;

                // İlkin forma üzərindəki məsafə
                const dx = initialPos[ix] - pinchPoint.x;
                const dy = initialPos[iy] - pinchPoint.y;
                const dz = initialPos[iz] - pinchPoint.z;
                const distToPinch = Math.sqrt(dx*dx + dy*dy + dz*dz);

                // Uzanma effekti
                const stretchFactor = Math.exp(-distToPinch * 0.8); 
                const offsetX = localHandX - pinchPoint.x;
                const offsetY = localHandY - pinchPoint.y;

                const targetX = initialPos[ix] + offsetX * stretchFactor;
                const targetY = initialPos[iy] + offsetY * stretchFactor;
                const targetZ = initialPos[iz];

                pos[ix] += (targetX - pos[ix]) * 0.15;
                pos[iy] += (targetY - pos[iy]) * 0.15;
                pos[iz] += (targetZ - pos[iz]) * 0.15;
            } else {
                pos[ix] += (initialPos[ix] - pos[ix]) * 0.1;
                pos[iy] += (initialPos[iy] - pos[iy]) * 0.1;
                pos[iz] += (initialPos[iz] - pos[iz]) * 0.1;
            }
        }

        points.geometry.attributes.position.needsUpdate = true;
        
        if (!isDisintegrated && !isPinching) {
            points.rotation.y += 0.005;
        }

        renderer.render(scene, camera);
    }

    const cameraInput = new Camera(videoElement, {
        onFrame: async () => { await hands.send({ image: videoElement }); },
        width: 1280, height: 720
    });

    window.onload = () => { 
        init(); 
        cameraInput.start(); 
        animate(); 
    };

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
