<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cosmic Saturn - Hand Tracking Visualization</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root {
            --neon-blue: #00f2ff;
            --deep-space: #010103;
            --glow-gold: #ffdd00;
        }

        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--deep-space);
            font-family: 'Segoe UI', sans-serif;
        }

        #input_video { display: none; }
        
        #canvas-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        #hand-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none;
            opacity: 0.4;
            transform: scaleX(-1);
        }

        .ui-overlay {
            position: absolute;
            top: 30px; left: 30px;
            z-index: 10;
            pointer-events: none;
            color: white;
            text-shadow: 0 0 20px var(--neon-blue);
        }

        .status-badge {
            background: rgba(0, 242, 255, 0.1);
            border-left: 3px solid var(--neon-blue);
            padding: 15px 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
            transition: all 0.3s ease;
        }

        .status-badge.gaming {
            border-left-color: var(--glow-gold);
            box-shadow: 0 0 20px rgba(255, 221, 0, 0.3);
            text-shadow: 0 0 20px var(--glow-gold);
        }

        #loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: var(--neon-blue);
            letter-spacing: 8px;
            font-weight: bold;
            text-shadow: 0 0 10px var(--neon-blue);
        }

        #axtarget-ui {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            font-size: 8rem;
            font-weight: 900;
            color: #fff;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 20px var(--neon-blue), 0 0 40px var(--neon-blue);
            letter-spacing: 15px;
            text-transform: uppercase;
        }

        #axtarget-ui.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            animation: glitch 0.3s infinite;
        }

        @keyframes glitch {
            0% { text-shadow: 2px 0 red, -2px 0 blue; }
            50% { text-shadow: -2px 0 red, 2px 0 blue; }
            100% { text-shadow: 2px 0 red, -2px 0 blue; }
        }
    </style>
</head>
<body>

    <div id="loading-screen">SİSTEM HAZIRLANIR...</div>
    <div id="axtarget-ui">AxtarGet</div>

    <div class="ui-overlay">
        <div id="status-badge" class="status-badge">
            <div style="font-size: 0.8rem; opacity: 0.7; letter-spacing: 2px;">KOSMİK ENERJİ</div>
            <div style="font-size: 1.6rem; font-weight: 300;" id="mode-text">ƏL GÖZLƏNİLİR</div>
        </div>
    </div>

    <video id="input_video"></video>
    <canvas id="hand-overlay"></canvas>
    <div id="canvas-container"></div>

    <script>
        const videoElement = document.getElementById('input_video');
        const modeText = document.getElementById('mode-text');
        const statusBadge = document.getElementById('status-badge');
        const loadingScreen = document.getElementById('loading-screen');
        const axtargetUI = document.getElementById('axtarget-ui');
        const handCanvas = document.getElementById('hand-overlay');
        const handCtx = handCanvas.getContext('2d');

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const maxParticles = 25000; 
        const particlesGeometry = new THREE.BufferGeometry();
        
        const posArray = new Float32Array(maxParticles * 3);
        const targetPosArray = new Float32Array(maxParticles * 3);
        const velocityArray = new Float32Array(maxParticles * 3); 

        const planetRadius = 5.8; 
        const ringInnerRadius = 8.0; 
        const ringOuterRadius = 12.5; 

        for(let i=0; i < maxParticles; i++) {
            const i3 = i * 3;
            posArray[i3] = (Math.random() - 0.5) * 120;
            posArray[i3+1] = (Math.random() - 0.5) * 100;
            posArray[i3+2] = (Math.random() - 0.5) * 100;

            if (i < 15000) { 
                const phi = Math.acos(-1 + (2 * i) / 15000);
                const theta = Math.sqrt(15000 * Math.PI) * phi;
                targetPosArray[i3] = planetRadius * Math.cos(theta) * Math.sin(phi);
                targetPosArray[i3+1] = planetRadius * Math.sin(theta) * Math.sin(phi);
                targetPosArray[i3+2] = planetRadius * Math.cos(phi);
            } else { 
                const angle = Math.random() * Math.PI * 2;
                const radius = ringInnerRadius + Math.random() * (ringOuterRadius - ringInnerRadius);
                targetPosArray[i3] = Math.cos(angle) * radius;
                targetPosArray[i3+1] = (Math.random() - 0.5) * 0.7; 
                targetPosArray[i3+2] = Math.sin(angle) * radius;
            }
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.16, 
            color: 0x00f2ff,
            transparent: true,
            opacity: 0,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        const particleMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleMesh);

        camera.position.z = 30; 

        let formationProgress = 0; 
        let isExploding = false;
        let explosionLife = 0;
        let lastAvgDist = 0;
        
        // Barmaq ucu izləmə mövqeyi
        let fingerTarget = new THREE.Vector3(0, 0, 0);
        let isSingleFingerActive = false;

        function animate() {
            requestAnimationFrame(animate);

            const positions = particlesGeometry.attributes.position.array;
            const activeCount = Math.floor(formationProgress * maxParticles);
            
            if (isExploding) {
                particlesMaterial.opacity = explosionLife;
                particlesMaterial.color.setHex(0xffffff);
                explosionLife *= 0.95;
                if (explosionLife < 0.01) isExploding = false;
            } else {
                if (isSingleFingerActive && formationProgress < 0.25) {
                    particlesMaterial.color.lerp(new THREE.Color(0xffdd00), 0.1);
                    particlesMaterial.opacity = 0.8;
                } else {
                    particlesMaterial.color.lerp(new THREE.Color(0x00f2ff), 0.1);
                    particlesMaterial.opacity = Math.max(0.5, formationProgress);
                }
            }

            for(let i=0; i < maxParticles; i++) {
                const i3 = i * 3;
                
                if (isExploding) {
                    positions[i3] += velocityArray[i3];
                    positions[i3+1] += velocityArray[i3+1];
                    positions[i3+2] += velocityArray[i3+2];
                    velocityArray[i3] *= 0.985;
                    velocityArray[i3+1] *= 0.985;
                    velocityArray[i3+2] *= 0.985;
                } else {
                    // Şəhadət barmağı ilə tozları idarə etmə (Maqnit/Girdab effekti)
                    if (isSingleFingerActive && formationProgress < 0.25) {
                        const dx = fingerTarget.x - positions[i3];
                        const dy = fingerTarget.y - positions[i3+1];
                        const dz = fingerTarget.z - positions[i3+2];
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (dist < 12) {
                            // Barmağa tərəf çəkmə gücü
                            const attraction = (12 - dist) / 100;
                            positions[i3] += dx * attraction;
                            positions[i3+1] += dy * attraction;
                            positions[i3+2] += dz * attraction;
                            
                            // Barmaq ucu ətrafında fırlanma (girdab)
                            positions[i3] += Math.cos(Date.now() * 0.005 + i) * 0.1;
                            positions[i3+1] += Math.sin(Date.now() * 0.005 + i) * 0.1;
                        }
                    }

                    if (i < activeCount) {
                        const lerpSpeed = 0.08 + (formationProgress * 0.06);
                        positions[i3] += (targetPosArray[i3] - positions[i3]) * lerpSpeed;
                        positions[i3+1] += (targetPosArray[i3+1] - positions[i3+1]) * lerpSpeed;
                        positions[i3+2] += (targetPosArray[i3+2] - positions[i3+2]) * lerpSpeed;
                    } else {
                        // Təbii dalğalanma
                        positions[i3] += Math.sin(Date.now() * 0.001 + i) * 0.025;
                        positions[i3+1] += Math.cos(Date.now() * 0.001 + i) * 0.025;
                    }
                }
            }
            particlesGeometry.attributes.position.needsUpdate = true;

            if (!isExploding) {
                const rotSpeed = isSingleFingerActive ? 0.02 : (0.003 + (formationProgress * 0.015));
                particleMesh.rotation.y += rotSpeed;
                particleMesh.rotation.x = 0.45;
            }

            renderer.render(scene, camera);
        }

        function triggerExplosion(force = 1) {
            isExploding = true;
            explosionLife = 1.0;
            const positions = particlesGeometry.attributes.position.array;
            
            for(let i=0; i < maxParticles; i++) {
                const i3 = i * 3;
                const dx = positions[i3];
                const dy = positions[i3+1];
                const dz = positions[i3+2];
                const mag = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;
                
                const push = 2.5 * force * (Math.random() + 0.4);
                velocityArray[i3] = (dx / mag) * push;
                velocityArray[i3+1] = (dy / mag) * push;
                velocityArray[i3+2] = (dz / mag) * push;
            }
        }

        function checkAxtarGetGesture(hand) {
            const indexUp = hand[8].y < hand[6].y;
            const middleUp = hand[12].y < hand[10].y;
            const ringDown = hand[16].y > hand[14].y;
            const pinkyDown = hand[20].y > hand[18].y;
            return indexUp && middleUp && ringDown && pinkyDown;
        }

        function onResults(results) {
            handCanvas.width = window.innerWidth;
            handCanvas.height = window.innerHeight;
            handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

            if (loadingScreen.style.display !== 'none') loadingScreen.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(handCtx, landmarks, HAND_CONNECTIONS, {color: isSingleFingerActive ? '#ffdd00' : '#00f2ff', lineWidth: 2});
                    drawLandmarks(handCtx, landmarks, {color: '#ffffff', lineWidth: 1, radius: 2});

                    const hand = landmarks;
                    
                    if (checkAxtarGetGesture(hand)) {
                        axtargetUI.classList.add('active');
                    } else {
                        axtargetUI.classList.remove('active');
                    }

                    // Tək barmaq (Şəhadət barmağı) izləmə
                    const indexTip = hand[8];
                    const middleTip = hand[12];
                    const ringTip = hand[16];
                    const pinkyTip = hand[20];
                    
                    // Yalnız şəhadət barmağı tam açıq olduqda
                    isSingleFingerActive = (indexTip.y < hand[6].y) && (middleTip.y > hand[10].y) && (ringTip.y > hand[14].y) && (pinkyTip.y > hand[18].y);
                    
                    if (isSingleFingerActive) {
                        // Normalizə olunmuş koordinatları Three.js dünyasına çeviririk
                        // MediaPipe x: 0-1 (soldan sağa), bizdə Three.js x mənfi/müsbət (sağdan sola güzgü əksi)
                        fingerTarget.x = (0.5 - indexTip.x) * 40; 
                        fingerTarget.y = (0.5 - indexTip.y) * 25;
                        fingerTarget.z = 5;
                    }

                    const wrist = hand[0];
                    const tips = [hand[8], hand[12], hand[16], hand[20]];
                    
                    let distSum = 0;
                    tips.forEach(t => {
                        distSum += Math.sqrt(Math.pow(t.x - wrist.x, 2) + Math.pow(t.y - wrist.y, 2));
                    });
                    const avgDist = distSum / 4;

                    const velocity = avgDist - lastAvgDist;
                    
                    if (velocity > 0.02 && formationProgress > 0.5) {
                        triggerExplosion(velocity * 70);
                        formationProgress = 0;
                        lastAvgDist = avgDist;
                        return;
                    }

                    const minFistDist = 0.15; 
                    const maxOpenDist = 0.28; 
                    
                    let strength = 1 - ((avgDist - minFistDist) / (maxOpenDist - minFistDist));
                    strength = Math.max(0, Math.min(1, strength));

                    if (!isExploding || strength > 0.4) {
                        if (strength > 0.3) isExploding = false;
                        formationProgress = strength;
                    }

                    lastAvgDist = avgDist;

                    const percent = Math.round(formationProgress * 100);
                    
                    if (isSingleFingerActive && formationProgress < 0.25) {
                        modeText.innerText = "TOZLARLA OYUN";
                        statusBadge.classList.add('gaming');
                    } else {
                        modeText.innerText = isExploding ? "ULTRA PARTLAYIŞ" : `GÜC: %${percent}`;
                        statusBadge.classList.remove('gaming');
                        modeText.style.color = isExploding ? "#fff" : "var(--neon-blue)";
                    }
                }
            } else {
                formationProgress *= 0.92;
                lastAvgDist = 0;
                isSingleFingerActive = false;
                modeText.innerText = "ƏL GÖZLƏNİLİR";
                statusBadge.classList.remove('gaming');
                axtargetUI.classList.remove('active');
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });
        hands.onResults(onResults);

        const cameraStream = new Camera(videoElement, {
            onFrame: async () => await hands.send({ image: videoElement }),
            width: 1280, height: 720
        });

        window.onload = () => {
            cameraStream.start();
            animate();
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
